package LeetCode_101书.动态规划.分割类型;

/*
279. 完全平方数

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

示例 1：
输入：n = 12
输出：3
解释：12 = 4 + 4 + 4

示例 2：
输入：n = 13
输出：2
解释：13 = 4 + 9

提示：
1 <= n <= 104
 */
import java.util.Arrays;

public class 完全平方数_279 {
    public static void main(String[] args){
        int n=101;
        System.out.println("最少需要"+numSquares(n)+"个完全平方数构成"+n);
    }

    //为何使用动态规划？因为总问题：我们想要实现 n 的所需最少完全平方数的数量，当我们给他减去一个完全平方数 k*k 后，
    //即问题变成我们想要实现 n-k*k 的所需最少完全平方数的数量，相当于问题的处理过程都是一样的！


    /*想好用动态规划就想想动态规划五步曲!
    1.确定dp[i]的下标以及dp值的含义：   实现i这个数，需要的最少的完全平方数的数量！

    2.确定状态转移方程：               首先dp[i] = dp[i-j^2] + 1, 意味着到dp[i]需要的数量等于 (到dp[i-j^2]的数量 再多1),
                                    例如：到12需要的数量, 等于到11(12-1*1)的数量+1，也等于到8(12-2*2)的数量+1，也等于到3(12-3*3)的数量+1
                                    我们需要确定到12的最少的数量,那么我们需要在上面提到的3个例子中，选择最小的那一个！
                                    于是得到状态转移方程 dp[i] 等于 当 i-j^2 >= 0 时, 所以 dp[i-j^2]+1 中最小的那一个！

    3.dp数组的初始化状态：             实现0所需的最少的完全平方数的数量为0,所以 dp[0] = 0;

    4.确定遍历顺序：                  由于dp[i]的值需要前面所有满足条件的dp[i-j^2]的值才能确定
                                    所以我们需要一个循环处理所有的i，而i-j^2是i之前的状态，所以i一定是从小到大循环
                                    而j的存在条件是i-j^2>0 -> j^2<i 所以j也必须要从小到大循环

    5.返回值:                        因为计算实现n这个数需要的最少的完全平方数，所以返回dp[n]
     */
    public static int numSquares(int n) {
        int[] dp = new int[n+1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0] = 0;

        for(int i=1; i<=n; i++){
            for (int j=1; j*j<=i; j++){
                dp[i] = Math.min(dp[i-j*j]+1, dp[i]);
            }
        }

        return dp[n];
    }
}
