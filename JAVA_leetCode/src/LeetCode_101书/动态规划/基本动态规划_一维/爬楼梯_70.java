package LeetCode_101书.动态规划.基本动态规划_一维;
/*
70. 爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例 1：
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

示例 2：
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
 */
public class 爬楼梯_70 {
    public static void main(String[] args){
        int n = 4;
        System.out.println("距离楼顶"+ n +"阶时，共有" + climbStairs(n) + "种方式可以爬到楼顶");
    }

    //最经典的一维 动态规划问题 : 即将一个总问题分解成很多个子问题解决！最后从子问题回到总问题上！
    //思路 一般看到题目有多少种方案，这种题意思不需要你列出来具体的多少种方案只需要计算有多少种方案，基本上就可以尝试用动态规划算法来解决问题。

    //关键词：有多少种方案 算法 !

    //想好用动态规划就想想动态规划五步曲!
    //1.确定dp[i]的下标以及dp值的含义：   爬到第i层楼梯，有dp[i]种方法
    //2.确定状态转移方程：               因为每次只可以爬1或者2个台阶所以，爬上当前台阶的方案应该是前面两个状态的方案的和即，dp[i] = dp[i-1] + dp[i-2]。
    //3.dp数组的初始化状态：             i=0级开始爬的，所以从第0级爬到第0级我们可以看作只有一种方案，即dp(0)=1； i=1代表从第0级到第1级也只有一种方案，即爬一级，dp(1)=1。
    //4.确定遍历顺序：                  分析状态转移方程可知当前值依赖前两个值来确定，所以递推顺序应该是从前往后
    //5.返回值:                        因为一共计算 n 阶楼梯有多少方案，所以返回dp[n]
    public static int climbStairs(int n) {
        if(n<=2) return n;

        //prev2是到达前2级阶梯的方案数，prev1是到达前1级阶梯方案数，now是到达当前楼的方案数
        int prev2 = 1;
        int prev1 = 2;
        int now = 0;

        //dp[i] = dp[i-1] + dp[i-2] 对应 now = prev1 + prev2
        for(int i=2; i<n; i++){
            now = prev1 + prev2;
            prev2 = prev1;
            prev1 = now;
        }

        return now;
    }
}
