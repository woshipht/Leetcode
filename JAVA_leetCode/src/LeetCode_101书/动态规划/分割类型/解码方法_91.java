package LeetCode_101书.动态规划.分割类型;

/*
91. 解码方法
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。

示例 1：
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）

示例 2：
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6)

示例 3：
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射

提示：
1 <= s.length <= 100
s 只包含数字，并且可能包含前导零。
 */
public class 解码方法_91 {
    public static void main(String[] args){
        String s = "11106";

        System.out.println("最多有"+numDecodings(s)+"种解码方式");
    }

    /*想好用动态规划就想想动态规划五步曲!
    1.确定dp[i]的下标以及dp值的含义：   以第i个数结尾时，最多有多少种编码方式

    2.确定状态转移方程：               情况①：如果出现0，那唯一能翻译的只有10,20； 所以如果当前字符为0就判断前一个字符是否是1与2，如果不是，证明永远无法翻译，返回0
                                    情况②：此时一定可以翻译 且 当前字符能和前一个字符组成组合，如果当前字符不为0，则
                                           1.当该字符自己单独一项时，能实现的最多编码数量等于 前一个字符 的最多编码数量，即在前一个的所有编码的末尾，加了该字符
                                           2.当该字符和前一个字符组合时，能实现的最多编码数量等于 前两个字符 的最多编码数量，即在前两个的所有编码的末尾，加了组合字符
                                           3.综上：在这种情况下，当前字符的最多编码数量 = 前一个字符 的最多编码数量 + 前两个字符 的最多编码数量
                                    情况③：此时一定可以翻译 且 当前字符能和前一个字符组成组合，如果当前字符为0，则
                                           1.该字符只能和前一个字符组合！能实现的最多编码数量等于 前两个字符 的最多编码数量，即在前两个的所有编码的末尾，加了组合字符
                                           2.综上：在这种情况下，当前字符的最多编码数量 = 前两个字符 的最多编码数量
                                    情况④：此时一定可以翻译 且 当前字符不能和前一个字符组成组合，则
                                           1.该字符只能自己单独一项！能实现的最多编码数量等于 前一个字符 的最多编码数量，即在前一个的所有编码的末尾，加了该字符
                                           2.综上：在这种情况下，当前字符的最多编码数量 = 前一个字符 的最多编码数量

    3.dp数组的初始化状态：             通过检测条件后，当到dp[1]时，一定只有1种编码，故dp[1]=1；
                                    当到dp[2]时，根据4种情况，与dp[0]相关的情况是：
                                    1.当前字符能和前一个字符组成组合，且当前字符不为0(即可以组合可以不组合)，此时有组合编码也有单独编码，dp[2]=dp[0]+dp[1]=2;
                                    2.当前字符能和前一个字符组成组合，且当前字符为0(即必须组合)，此时只有1种编码，即新加的组合编码，dp[2]=dp[0]=1;
                                    故dp[0]应该等于1(可以理解为，初始有一种编码方式为 null !)

    4.确定遍历顺序：                  由于当前值依赖前2个值或者前1个值来确定，所以递推顺序应该是从前往后

    5.返回值:                        因为计算以第n个数结尾，最多有多少种编码方式，所以返回dp[n]
     */
    public static int numDecodings(String s) {
        if(s.length() == 0 || s.charAt(0) == '0'){
            return 0;
        }
        if(s.length() == 1){
            return 1;
        }

        var dp = new int[s.length()+1];
        //初始状态：通过检测条件后，当到dp[1]时，一定只有1种编码，故dp[1]=1；
        //                     当到dp[2]时，根据4种情况，与dp[0]相关的情况是：
        //                          1.当前字符能和前一个字符组成组合，且当前字符不为0(即可以组合可以不组合)，此时有组合编码也有单独编码，dp[2]=dp[0]+dp[1]=2;
        //                          2.当前字符能和前一个字符组成组合，且当前字符为0(即必须组合)，此时只有1种编码，即新加的组合编码，dp[2]=dp[0]=1;
        //                     故dp[0]应该等于1(可以理解为，初始有一种编码方式为 null !)
        dp[0] = 1;
        dp[1] = 1;

        for(int i=2; i<=s.length(); i++){
            //情况①：如果出现0，那唯一能翻译的只有10,20； 所以如果当前字符为0就判断前一个字符是否是1与2，如果不是，证明永远无法翻译，返回0
            if(s.charAt(i-1) == '0' && (s.charAt(i-2) > '2' || s.charAt(i-2) == '0')){
                return 0;
            }
            //判断条件：此时一定可以翻译，检测当前字符能不能和前一个字符组成组合满足1-26之间的数字！
            if(s.charAt(i-2) == '1' || (s.charAt(i-2) == '2' && s.charAt(i-1) < '7')){
                //情况②：此时一定可以翻译 且 当前字符能和前一个字符组成组合，如果当前字符不为0，则
                //       1.当该字符自己单独一项时，能实现的最多编码数量等于 前一个字符 的最多编码数量，即在前一个的所有编码的末尾，加了该字符
                //       2.当该字符和前一个字符组合时，能实现的最多编码数量等于 前两个字符 的最多编码数量，即在前两个的所有编码的末尾，加了组合字符
                //       3.综上：在这种情况下，当前字符的最多编码数量 = 前一个字符 的最多编码数量 + 前两个字符 的最多编码数量
                if(s.charAt(i-1) != '0'){
                    dp[i] = dp[i-1] + dp[i-2];

                //情况③：此时一定可以翻译 且 当前字符能和前一个字符组成组合，如果当前字符为0，则
                //       1.该字符只能和前一个字符组合！能实现的最多编码数量等于 前两个字符 的最多编码数量，即在前两个的所有编码的末尾，加了组合字符
                //       2.综上：在这种情况下，当前字符的最多编码数量 = 前两个字符 的最多编码数量
                }else {
                    dp[i] = dp[i-2];
                }
            //情况④：此时一定可以翻译 且 当前字符不能和前一个字符组成组合，则
            //       1.该字符只能自己单独一项！能实现的最多编码数量等于 前一个字符 的最多编码数量，即在前一个的所有编码的末尾，加了该字符
            //       2.综上：在这种情况下，当前字符的最多编码数量 = 前一个字符 的最多编码数量
            }else {
                dp[i] = dp[i-1];
            }
        }

        return dp[s.length()];
    }
}
